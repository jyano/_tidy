$L('sens', 'dfr', 'shapes')
b.fs = b.e = b.eF = function (fn) {
	var b = this
	var arr = []
	var f = b.f()
	while (f) {
		arr.push(f)
		f = f.N()
	}
	if (fn) {
		_.e(arr, function (it) {
			fn(it, fn)
		});
		return b
	}
	return arr
}
b.DF = b.dsFx = function (fixt) {
	this.DestroyFixture(fixt)
	return this
}
b.empty = b.clear = function () {
	return this.fs(function (f) {
		f.kill()
	})
}
b.rmF = function (f) {
	if (f) {
		this.DF(f)
	}
	else {
		this.fs(function (f) {
			this.rmF(f)
		})
	}
	return this
}
b.grp = function (i) {
	f = this.fixt()
	if (U(i)) {
		return f.grp()
	}
	f.grp(i);
	$l('set to ' + i)
	return this
}
b.onAddFxt = function () {
	this.rMD()
	return this
}
b2d.fxPar = $$$cirORpoly$$$ = function (fxs, fn) {
	var b = this
	//if its not an array,, assume is fine, and leave it as is
	fxs = _.m(fxs, function (f) {
		return !A(f) ? f :
				f.length == 1 || f.length == 3 ?
						$cF.apply(null, f) :
						$pF.apply(null, f)
	})
	// fn = _.b(fn, b) ?
	if (fn) {
		_.e(fxs, fn);
		return b
	}
	return fxs
	//if (f.isSensor) {return b2d.polySens.apply(null, f)}
}
b.fxPar = function (f) {
// so how does that work??
// the array len determines if it is to make 
// a circle fxt ($cF) or rect fixt $pF
	var b = this
	b2d.fxPar(f, function (fD) {
		b.f(fD)
	})
	return b
}
b.fD = b.fxD = b.$fD = function (fD) {
//return this.CF( $fD(fD) )
	return this.CF($fD.apply(null, arguments))
}
b.GFL = function () {
	return this.GetFixtureList()
}
b.n = b.num = b.count = function () {
	return this.m_fixtureCount
}
b.fs = function (fn) {
	var b = this, g = G(arguments),
			fl = b.f(), fn = g.f, arr = []
	while (fl) {
		arr.push(fl);
		fl = fl.GetNext()
	}
	if (N(fn)) {
		return arr[fn]
	}
	if (F(fn)) {
		_.e(arr, fn);
		return b
	}
	if (b2d.iB(fn)) {
		b.fs(function (f) {
			fn.pol(f)
		})
		return fn
	}
	return arr
	/*
	 if (g.p) {//order by biggest
	 arr = arr.sort(function (a, b) {return b.area() - a.area() }) }
	 if (g.n) {//order by smallest
	 arr = arr.sort(function (a, b) {return a.area() - b.area()}) }
	 */
	function alt() {
		b.fixts = b.each = b.eachFixt = function (func) {
			var fl = this.fixt(), arr = [],
					g = G(arguments), func = g[0]
			while (fl) {
				arr.push(fl);
				fl = fl.GetNext()
			}
			//order by biggest
			if (g.p) {
				arr = arr.sort(function (a, b) {
					return b.area() - a.area()
				})
			}
			//order by smallest
			if (g.n) {
				arr = arr.sort(function (a, b) {
					return a.area() - b.area()
				})
			}
			if (F(func)) {
				_.each(arr, func);
				return this
			}
			return arr
		}
	}
	
	// = b.e
}
b.CF = function () {//b.CF = b.CreateFixture
	return this.CreateFixture.apply(this, arguments)
}
b.CF_ = function () {//b.CF = b.CreateFixture
	this.CreateFixture.apply(this, arguments)
	return this
}
b.CF2 = function () {
	return this.CreateFixture2.apply(this, arguments)
}
b.dsF = b.dF = b.DF = b.DFx = function (f) {
	this.DestroyFixture(f);
	return this
}
b.GFL = b.GFxL = function () {
	return this.GetFixtureList()
}
function sens() {
	b.togSen = function () {
		return this.sensor(!this.sensor())
	}
	b.sen = b.iS = function (s) {
		var b = this
		var f = b.f()
		if (U(isSensor)) {
			return f.m_isSensor
		}
		b.fs(function (f) {
			f.sen(s)
		})
		return b
	}
	b.s1 = b.sens = function () {//turns on
		this.f().sensor(true);
		return this
	}
	b.sr1 = b.s1 = b.mS = function () {
		return this.sSr(1)
	}
	b.sSr = function (sr) {
		var b = this
		b.fs(function (f) {
			f.sr(sr)
		})
		return b
	}
	b.sr = b.sens = function (sr) {
		var b = this
		if (U(sr)) {
			return b.f().iSr()
		}
		b.sSr(sr)
		return b
	}
}
function dfr() {
	b.de = function (den) {
		if (U(den)) {
			return this.list().GetDensity()
		}
		this.each(function (f) {
			f.SetDensity(den)
		})
		this.ResetMassData()
		return this
	}
	b.fr = function (fric) {
		if (U(fric)) {
			return this.list().GetFriction()
		}
		this.each(function (f) {
			f.SetFriction(fric)
		})
		return this
	}
	b.re = function (rest) {
		if (U(rest)) {
			return this.list().GetRestitution()
		}
		this.each(function (f) {
			f.SetRestitution(rest)
		})
		return this
	}
	b.DFR = b.DFB = function (d, f, r) {
		return this.den(d).fric(f).rest(r)
	}
	b.DBF = function (d, r, f) {
		var b = this
		b.den(d)
		if (N(r)) {
			this.rest(r)
		}
		if (N(f)) {
			b.fric(f)
		}
		return b
		function alt() {
			b.DBF = function (d, r, f) {
				var b = this
				b.den(d)
				if (N(r)) {
					this.rest(r)
				}
				if (N(f)) {
					b.fric(f)
				}
				return b
			}
		}
	}
	b.fr = b.fric = function (fr) {
		var b = this
		if (U(fr)) {
			return b.f().GetFriction()
		}
		b.fs(function (f) {
			f.SetFriction(fr)
		})
		return b
		function alt() {
			b.fric = function (fric) {
				if (U(fric)) {
					return this.list().GetFriction()
				}
				this.each(function (f) {
					f.SetFriction(fric)
				})
				return this
			}
		}
	}
	b.de = b.d = b.den = function (d) {
		var b = this
		if (U(d)) {
			return b.f().GetDensity()
		}
		b.fs(function (f) {
			f.SetDensity(d)
		})
		b.ResetMassData()
		return b
		function alt() {
			b.den = function (den) {
				if (U(den)) {
					return this.list().GetDensity()
				}
				this.each(function (f) {
					f.SetDensity(den)
				})
				this.ResetMassData()
				return this
			}
		}
	}
	b.re = b.r = b.bo = b.rest = function (r) {
		function alt() {
			b.bo = b.rest = function (rest) {
				if (U(rest)) {
					return this.list().GetRestitution()
				}
				this.each(function (f) {
					f.SetRestitution(rest)
				})
				return this
			}
		}
		
		var b = this
		if (U(r)) {
			return b.f().GetRestitution()
		}
		b.fs(function (f) {
			f.SetRestitution(r)
		})
		return b
	}
	b.de = b.den = function (de) {
		var b = this//$l('b.de boxBody.js')
		if (U(de)) {
			return b.f().de()
		}
		b.e(function (f) {
			f.SetDensity(de)
		})
		return this.RMD()
	}
	b.de1 = function () {
		return this.de(1)
	}
	b.fr = b.fric = function (fr) {
		var b = this
		return D(fr) ?
				b.fs(function (f) {
					f.SetFriction(fr)
				}) :
				b.list().GetFriction()
	}
	b.re = b.rest = function (re) {
		var b = this
		return D(re) ? b.fs(function (f) {
			f.re(re)
		}) :
				b.f() ? b.f().GetRestitution() : false
	}
}
b.f = function (fD) {//b.createFixture = b.cF = b.fixt1 = b.shape =
	var b = this, f;
	if (U(fD)) {
		return this.GetFixtureList()
	}
	// can pass a CODED array of fixts (will get parsed)
	if (A(fD)) {
		_.each(b2d.fixtParse(fD),
				function (fd) {
					b.fixt(fd)
				})
		return b
	}
	if (!b2d.isFixtDef(fD)) {
		fD = b2d.fixt.apply(b2d, arguments)
	}
	//create the fixt
	f = this.CreateFixture(fD)
	//assign it classes specified in the fixt def
	if (A(fD.classes)) {
		_.each(fD.classes,
				function (clas) {
					f.K(clas)
				})
	}
	return f
	//= b.fixt = b.list
}
b.f = function (fD) {
	var b = this, g = G(arguments)
	if (g.u) {
		return b.GFL()
	}
	if (g.A_) {
		_.e(b2d.fxPar(g.f), function (fD) {
			b.f(fD)
		})
		return b
	}
	var f = b.CF(g.f)
	if (g.f.K()) {
		f.K(g.f.K())
	}
	return f
}
b.GP = function () {
	var b = this
	var wPts = b.wPts()
	return M.poly(wPts)
}
b.lGP = function () {
	var b = this
	var lPts = this.pts()
	return Math.poly(lPts)
}
b.PD = b.pD = function () {
	//b.P =
	var b = this, p,
			fs = b.fs()
	if (!_.f(fs)) {
		return new PolyDefault()
	}
	p = M.p(_.f(fs))
	_.eR(fs, function (f) {
		p = p.U(f)
	})
	return p//p.reg(b)
	//this returns a gPoly
}
b.pD = function () {
	var b = this, f = b.f(), g = G(arguments), pD = $pD()
	if (!f) {
		return pD
	}
	// if the body has no freqkin fixts.. 
	// if its an infant body , massless? fixtureless
	pD = M.p(f)
	_.eR(b.fs(), function (f) {
		pD = pD.U(f)
	})
	return pD
}
b.polDefault = b.polDef = b.bolDf = b.pD = b.P = function () {
	var b = this, p, fs = b.fs()
	if (!_.f(fs)) {
		return new PolyDefault()
	}
	p = M.p(_.f(fs))
	_.eR(fs, function (f) {
		p = p.U(f)
	})
	return p//p.reg(b)
	//this returns a gPoly
}
b.ps = function (fn) {
	alert('b.ps sucks')
	var b = this,
			arr = [],
			p = b.uni()
	if (F(fn)) {
		p.ps(b, fn);
		return b
	}
	p.ps(b, function (v) {
		arr.push(v)
	})
	return arr
}
b.each = b.eachFixt = function (func) {
	var fl = this.GetFixtureList()
	var withList = function self(list, func) {
		func(list)
		list = list.GetNext()
		if (list) {
			return self(list, func)
		}
	}
	withList(fl, func)
}
b.worldVec = function (vec, y) {
	if (N(vec) && N(y)) {
		vec = V(vec, y)
	}
	if (U(vec)) {
		vec = V(0, -100)
	}
	return this.GetWorldVector(vec)
}
b.count = function () {
	return this.m_fixtureCount
}
b.iK = b.isKin = function () {
	return this.GetType() == 1
}
b.kin = function () {
	return this.type(1)
}
b.lC = function () {
	var b = this, w = b.W(), g = G(arguments)
	//gives {x,y}, but of its CENTER-OF-MASS
	if (g.p) {
		return b.XY(w.hW, w.hH)
	}
	return b.GetLocalCenter().m()
}
b.lVL = b.linVelLoc = function (v, y) {
//lin vel from local point ... use case?
	v = V(v, y)
	return this.GetLinearVelocityFromLocalPoint(v.div()).mult().dec(2)
}
b.vX = function (x) {
	var b = this, g = G(arguments),
			v = b.lV()
	if (g.u) {
		return v.x
	}
	b.lV(x, v.y)
	return b
	function alt() {
		b.vX = function (x) {
			if (U(x)) {
				return this.lV().x
			}
			return this.lV(x, this.lV().y)
		}
	}
}
b.vY = function (y) {
	function alt() {
		b.vY = function (y) {
			if (U(y)) {
				return this.lV().y
			}
			return this.lV(this.lV().x, y)
		}
	}
	
	var b = this
	if (U(y)) {
		return b.lV().y
	}
	return b.lV(b.lV().x, y)
}
b.lVW = b.linVelWor = function (v, y) {//lin vel from world point
	v = V(v, y)
	return this.GetLinearVelocityFromWorldPoint(v.div()).mult().dec(2)
}
b.GLV = function () {
	return this.GetLinearVelocity()
}
b.GAV = function () {
	return this.GetAngularVelocity()
}
b.SLV = function (lV) {
	this.SetLinearVelocity(lV);
	return this
}
b.SAV = function (aV) {
	this.SetAngularVelocity(aV)
	return this
}
b.GD = b.GDf = function () {
	return this.GetDefinition()
}
b.GLD = function () {
	return this.GetLinearDamping()
}
b.GAD = function () {
	return this.GetAngularDamping()
}
b.SLD = function (lD) {
	this.SetLinearDamping(lD);
	return this
}
b.SAD = function (aD) {
	this.SetAngularDamping(aD);
	return this
}
b.GI = function () {
	return this.GetInertia()
}
b.AF = function (v, c) {
	this.ApplyForce(v, c);
	return this
}
b.AI = function () {
	this.ApplyImpulse.apply(this, arguments)
	return this
}
b.I = function (imp, pt, pt2) {
	/*
	 //apply impulse. pass impulse as two nums, or obj //and pass in location, defaults to body center
	 if (g.A) {return b.I.apply(b, g.f)}
	 o = N(g.s) ? {i: V(g.f, g.s), v: g.t} : {i: g.f, v: g.s}
	 o.i = o.i || b.v().d(40)
	 o.v = o.v || b.wC()
	 b.ApplyImpulse(o.i, o.v.div())
	 */
	var b = this, g = G(arguments), o
	b.imp = function (imp, pt) {
		return this.AI(imp, pt || this.GWC())
	}
	o = O(g.f) ? {imp: g.f, pt: g.s} :
	{imp: V(g.f, g.s), pt: g.t}
	o.imp = o.imp || b.worldVec().d(40)
	return b.imp(o.imp, o.pt)
}
b.F = function (v, c, c2) {
	if (N(c)) {
		return this.F(V(v, c), c2)
	}
	if (U(c)) {
		c = this.GWC()
	}
	this.ApplyForce(v, c)
	return this
}
b.lD = function (damp) {
	if (U(damp)) {
		return this.GetLinearDamping()
	}
	this.SetLinearDamping(damp)
	return this
}
b.aD = function () {
	var b = this, g = G(arguments),
			d = g[0]
	if (U(d)) {
		return b.GetAngularDamping()
	}
	if (d == '++') {
		d = 10000
	}
	b.SetAngularDamping(d)
	return b
	function alt() {
		b.aD = function (damp) {
			if (U(damp)) {
				return this.GetAngularDamping()
			}
			this.SetAngularDamping(damp)
			return this
		}
	}
}
b.aV = function (vel) {
	if (U(vel)) {
		return this.GetAngularVelocity()
	}
	this.SetAngularVelocity(vel)
	return this
}
b.lV = b.lV$ = function (lV, y) {
	var b = this
	var v = this.GetLinearVelocity()
	if (U(lV)) {
		return v
	}
	if (N(y)) {
		lV = V(lV, y)
	}
	else if (N(lV)) {
		lV = V(lV, v.y)
	}
	else if (g.m) {
		return this.lV(R() ? 1 : -1, R() ? 1 : -1)
	}
	this.SetLinearVelocity(lV)
	return this.wakeUp()
	function alt() {
		b.lV = function () {
			var b = this, g = G(arguments),
					v = b.GetLinearVelocity(), o, lV
			// can pass in V | x,y
			// or if u pass JUST x, it will set ONLY x, keeping y UNTOUCHED
			//(same as vX) .. but why? eh.. can be better, if u already hav vX, no need to default to it
			if (g.u) {
				return v
			}
			lV = U(g[1]) ? V(g[0], v.y) : V(g[0], g[1])
			b.SetLinearVelocity(lV)
			return b.wakeUp()
		}
		b.lV = function (vel, n2) {
			if (U(vel)) {
				return this.GetLinearVelocity()
			}
			if (N(vel)) {
				vel = V(vel, n2)
			}
			this.SetLinearVelocity(vel)
			return this
		}
	}
}
b.F = function () {
	function alt() {
		b.F = b.constF = function (v, c, c2) {//b.applyForce = b.aF  =
			var b = this, g = G(arguments), v = g[0], c = g[1], c2 = g[2]
			if (N(c)) {
				return b.F(V(v, c), c2)
			}
			if (U(c)) {
				c = b.worldCenter()
			} // gotta adjust this
			b.ApplyForce(v, c)
			if (g.p) {
				cjs.tick(function () {
					b.ApplyForce(v, c)
				})
			}
			return b
		}      //apply force. pass impulse as two nums, or obj //and pass in location, defaults to body center
	}
	
	//apply force. pass impulse as two nums, or obj
// and pass in location, defaults to body center
	var b = this, g = G(arguments), o
	o = N(g[1]) ? {f: V(g[0], g[1]), wP: g[2]}
			: {f: V(g[0]), wP: g[1]}
	o.wP = o.wP || b.wC()
	b.ApplyForce(o.f, o.wP)
	if (g.p) {
		cjs.t(function () {
			b.ApplyForce(o.f, o.wP)
		})
	}
	return b
}
b.mass = function (m) {
	if (U(m)) {
		return ( this.GetMass() * 900 ) / 100
	}
}
b.lVL = function (x, y) {
	var b = this
	b.GLVFLP = function (v) {
		return this.GetLinearVelocityFromLocalPoint(v)
	}
	return this.GLVFLP(V(x, y, '-'))
}
b.lVW = function (x, y) {
	var b = this
	b.GLVFWP = function (v) {
		return this.GetLinearVelocityFromWorldPoint(v)
	}
	return this.GLVFWP(V(x, y, '-'))
}
b.cl = b.b = b.collide = function () {
	var b = this, w = b.W(), g = G(arguments), o
	// if body collides with ANYTHING
	// if body collides with body/fixt of specific kind
	// if body collides with specific body
	// if body collides with specific fixt
	// but always pass fixt into the cb
	if (F(g.f) && F(g.s)) {
		this.cl(g.f)
		w.end(b, g.s)
		return b
	}
	o = g.F_ ? {fn: g.f, k: ''} : {k: g.f, fn: g.s}
	w.b(function (cx) {
		var fA = cx.A(), fB = cx.B()
		if (b.of(cx.a()) && fB.of(o.k)) {
			if (o.fn) {
				_.b(o.fn, fA)(fB, cx);
				return w
			}
			return [fA, fB, cx]
		}
		else if (b.of(cx.b()) && fA.of(o.k)) {
			if (o.fn) {
				_.b(o.fn, fB)(fA, cx);
				return w
			}
			return [fB, fA, cx]
		}
	})
	return b
}
b.coll = b.collWithKind = function (func, func2) {
	var that = this
	if (S(func) && F(func2)) {
		this.W().begin(function (cx) {
			if (cx.a() == that && cx.b().is(func)) {
				func2(cx.b())
			}
			if (cx.b() == that && cx.a().is(func)) {
				func2(cx.a())
			}
		})
	}
	else {
		w.begin(function (cx) {
			if (cx.a() == that) {
				func(cx.a())
			}
			if (cx.b() == that) {
				func(cx.b())
			}
		})
	}
	return this
}
b.cl = b.col = b.coll = function (k, fn) {
	var b = this, w = b.W()    //merged these 2, but the the fixt 'coll' met is more complete/flexible  //b.collWithKind =
	// if body collides with ANYTHING
	// if body collides with body/fixt of specific kind
	// if body collides with specific body
	// if body collides with specific fixt
	// but always pass fixt into the cb
	if (F(k)) {
		fn = k;
		k = ''
	} //if clas NOT passed in
	w.beg(function (cx) {
		var fA = cx.A(), fB = cx.B(), bA = cx.a(), bB = cx.b()
		if (b.is(bA) && fB.of(k)) {
			_.b(fn, fA)(fB, cx)
		}
		if (b.is(bB) && fA.of(k)) {
			_.b(fn, fB)(fA, cx)
		}
	})
	return b
}
b.cl = function () {
	var b = this, w = b.W(), g = G(arguments), o
	o = g.F_ ? {fn: g.f, in0: g.s} :
	{k: g.f, fn: g.s, in0: g.t}
	o.k ? w.cl(b, o.k, o.fn, o.in0) :
			w.cl(b, o.fn, o.in0)
	return b
}
b.cl0 = function () {
	var b = this, w = b.W(), g = G(arguments), o
	o = g.F_ ? {fn: g.f, in0: g.s} :
	{k: g.f, fn: g.s, in0: g.t}
	o.k ? w.cl0(b, o.k, o.fn) :
			w.cl0(b, o.fn)
	return b
}
b.coll = function (clas, func) {
	var body = this, w = body.wor()    //merged these 2, but the the fixt 'coll' met is more complete/flexible  //b.collWithKind =
	// if body collides with ANYTHING
	// if body collides with body/fixt of specific kind
	// if body collides with specific body
	// if body collides with specific fixt
	// but always pass fixt into the cb
	if (F(clas)) {
		func = clas;
		clas = ''
	} //if clas NOT passed in
	w.beg(function (cx) {
		var fA = cx.A(), fB = cx.B(), bA = cx.a(), bB = cx.b()
		if (body.is(bA) && fB.of(clas)) {
			_.bind(func, fA)(fB, cx)
		}
		if (body.is(bB) && fA.of(clas)) {
			_.bind(func, fB)(fA, cx)
		}
	})
	return this
}
b.col2 = function (func) { //brilliant   =b.eachCx =b.withFixtsCollidingWithMe
	//uses the OTHER way to check contacts !!!!!!
	var body = this, contacts = body.cx(),
			next, fixt, notMyFixt, fA, fB
	if (!contacts) {
		$l('no contacts');
		return false
	}
	c = contacts = contacts.contact
	n = 0
	while (contacts) {
		n++
		next = contacts.GetNext()
		fA = contacts.A()
		fB = contacts.B()
		bA = contacts.a()
		notMyFixt = body.is(bA) ? fB : fA  //find the fixture whose body is not me
		$l(notMyFixt.K() + ' - ' + notMyFixt.B().K())
		_.bind(func, body)(notMyFixt, contacts)   //and call func on IT (along with the actual cx)
		contacts = next
	}
}
b.pre = function () {
	var b = this, w = b.W(), g = G(arguments)
	w.pre(function (cx) {
		cx.w(b, g[0], g[1], g[2])
	})
}
b.pre = function () {
	var b = this, w = b.W(), g = G(arguments)
	w.pre(function (cx) {
		cx.w(b, g.f, g.s, g.t)
	})
}
b.end = function () {
	var b = this, w = b.W(), g = G(arguments), o
	o = F(g.s) ? {k: g.f, fn: g.s} : {fn: g.f}
	o.k ? w.end(b, o.k, o.fn) : w.end(b, o.fn)
	return b
}
b.gK = function () {
	this.classes = this.classes || []
	return this.classes.join(' ')
}
b.aK = function (clas) {
	var that = this, func
	this.classes = this.classes || []
	if (U(clas)) {
		$l('need to provide a class!');
		return this
	}
	if (F(clas)) { // use case??
		func = _.bind(clas, that)
		this.addClass(func(that.getClasses()))
		return this
	}
	_.each(arguments, function (clas) {
		if (S(clas)) {
			_.each(clas.trim().split(' '), function (clas) {
				clas = clas.trim()
				if (clas != '' && !that.hasClass(clas)) {
					that.classes.push(clas)
				}
			})
		}
	})
	return this
}
b.K = function () {
	var b = this, g = G(arguments);
	this._K = this._K || []
	/*
	 if (U(k)) {
	 return this.getClasses()
	 }
	 _.each(arguments, function (k) {
	 b.addClass(k)
	 })
	 */
	if (g.u) {
		return this._K.join(' ')
	}
	if (g.O) {
		this.K(g.f.k);
		return this
	}
	_.eW(g.f, function (k) {
		if (!b.of(k)) {
			b._K.push(k)
		}
	})
	return this
}
b.of = function (k) {
	if (b2d.iF(k)) {
		k = k.B()
	}
	return !k || _.ct(this._K, k) || this == k
}
b.is = function (k) {
	return k && this.of(k)
	/*
	 var that = this, is = false
	 _.each(arguments, function (k) {
	 if (that.K() == k) {
	 is = true
	 }
	 })
	 return is
	 */
}
b.decor = function (g) {
	var b = this
	if (g.n) {
		b.mS()
	}
	else if (g.p) {
		b.mBu()
	}
	else if (g.m) {
		b.mS().mBu()
	}
	return b
}
b.wP = b.wPt = function (x, y) {
	var b = this
	return b.GetWorldPoint(V(x, y).div()).mult()
}
b.wP = b.wPt = function (x, y) {
	var b = this
	return b.GetWorldPoint(V(x, y).div()).mult()
}
b.$$ = function (fn) {
	var b = this, w = b.W()
	w.$$(function (o) {
		w.q(o.x, o.y, function (f) {
			if (f.of(b)) {
				_.b(fn, f)(o)
			}
		})
	})
	return b
}
b.$ = function (fn) {
	var b = this, w = b.W()
	w.$(function (o) {
		w.q(o.x, o.y, function (f) {
			if (f.of(b)) {
				_.b(fn, f)(o)
			}
		})
	})
	return b
}
b.gI = function (gI) {
	return this.fs(function (f) {
		f.gI(gI)
	})
}
b.cat = function () {
	var b = this, g = G(arguments);
	if (g.u) {
		return b
	}
	b.fs(function (f) {
		f.cat(g.f)
	});
	return b
}
b.bit = function (cat, msk) {
	if (N(cat)) {
		this.cat(cat)
	}
	if (N(msk) || A(msk)) {
		this.msk(msk)
	}
	return this
}
b.msk = function () {
	var b = this, g = G(arguments);
	b.fs(function (f) {
		f.msk(g.f)
	})
	return b
}
b.groupIX = b.grp = function (i) {
	if (U(i)) {
		return this.f().grp()
	}
	this.fs(function (f) {
		f.grp(i)
	})
	return this
}
b.groupIx = b.grp = function (grp) {
	var b = this
	b.fs(function (f) {
		f.grp(grp)
	})
	return b
}
b.cx = function (fn) {
	var b = this, c, next, n, ent// uses contact list //uses the OTHER way to check cxs !!!!!!
	if (U(fn)) {
		return b.GetContactList()
	}
	if (!(c = b.cx())) {
		$l('!');
		return
	}
	n = 0
	c = c.contact
	while (cx) {
		next = cx.GetNext()
		//////////////
		fn = _.b(fn, b)
		ent = b.of(cx.a()) ? cx.B() : cx.A()
		fn(ent, cx, n++)
		/////////////
		cx = next
	}
}
b.sr = b.sen = function () {
	var b = this, f = b.f(), g = G(arguments)
	if (g.d) {
		return b.sen(!b.sen())
	}//b.sen('/')->toggle sen
	if (U(g[0])) {
		return f.m_isSensor
	}
	f.m_isSensor = g[0] ? true : false
	return b
}
//linVel from worldPt
b.lVW = b.linVelWor = function () {
	var b = this, g = G(arguments),
			v = V(g[0], g[1]),
			vel
	if (g.m) {
		vel = b.GetLinearVelocityFromWorldPoint(v.div()).mult()
	}
	else {
		vel = b.GetLinearVelocityFromWorldPoint(v)
	}
	return vel.dec(2)
}
//linVel from LocalPoint.. i think not used
b.lVL = b.linVelLoc = function (v, y) {
	v = V(v, y);
	return this.GetLinearVelocityFromLocalPoint(v.div()).mult().dec(2)
}//usecase?
b.wl = b.whi = b.while = function (k, fn) {
	var b = this, w = b.W()
	w.wl(b, k, fn)
	return b
}
b.wn = b.whe = b.when = function (k, oB, oE) {
	var b = this,
			w = b.W()
	w.when(b, k, oB, oE)
	return b
}
b.my = function (k, fn) {
	var b = this, w = b.W()
	if (F(fn)) {
		w.b(function (cx) {
			cx.w(b,
					function (f) {
						if (this.of(k)) {
							_.b(fn, this)(f, cx)
						}
					})
		})
	}
	else {
		w.when(b,
				function () {
					b.my[k] = 1
				},
				function () {
					b.my[k] = 0
				})
	}
	return b
}  //so trig is to specify a sp body on what to do when one of its own fixts of a certain k has a col
function generalBodyStuffAdvanced() {
	function bodyTransformClone() {
		b.copyXY = function (b1) {
			var b = this
			return b.XY(b1.X(), b1.Y()).rt(b1.rt())
		}
	}
}